<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
/**
 *  [JavaScript Design Pattern]
 * 
 *  1. Creational Design Pattern
 *  2. Structural Design Pattern
 *  3. Behavioral Design Pattern
 */

// [Creational Design Pattern]
// 1. Constructor / Builder
// - 복잡한 오브젝트의 구성을 해당 표현과 분리하여 동일한 구성 프로세스를 통해 다양한 표현을 생성
// class Person {
//     constructor (name, age, bro) {
//         this.name = name
//         this.age = age
//         this.bro = bro
//     }
// }

// const jace = new Person('jace', 30, null)
// const yasuo = new Person('yasuo', 28, null)

// jace.bro = 'jin'
// console.log("jace :: ", jace)

// const yone = new Person('yone', 30, null)
// yasuo.bro = yone
// console.log("yasuo :: ", yasuo)

// 2. Factory
// - 단일 오브젝트를 만들기 위한 인터페이스를 정의하지만 서브 클래스가 인스턴스화할 클래스를 결정
// - 팩토리 메서드를 사용하면 클래스가 서브 클래스에 대한 인스턴스화를 연기할 수 있음
// - 객체 간의 결합도를 낮추고 유지보수가 수월
// function AnimalFactory() {
//     this.CreateAnimal = function(animalType) {
//         let animal
        
//         switch(animalType) {
//             case 'dog':
//                 animal = new Dog();
//                 break;
//             default:
//                 animal = new Cat()
//         }
//         return animal
//     }
// }

// const Dog = function() {
//     this.makeSound = () => {
//         console.log('Woof!')
//     }
// }
// const Cat = function() {
//     this.makeSound = () => {
//         console.log('prrr meow!')
//     }
// }

// const factory = new AnimalFactory()

// const pepe = factory.CreateAnimal('dog')
// pepe.makeSound()

// const momo = factory.CreateAnimal('cat')
// momo.makeSound()

// 3. Prototype
// - 프로토타입 인스턴스를 사용하여 생성할 오브젝트의 종류를 지정하고,
// - 기존 오브젝트의 뼈대에서 새 오브젝트를 생성하여 성능을 높이고 메모리 공간을 최소화
// - 객체 생성 방법이 복잡하거나 동적으로 객체를 생성할 때 유용
// const macBook = {
//     color: 'silver',
//     turnOn() {
//         console.log("Turning on...")
//     },
//     turnOff() {
//         console.log("Turning off...")
//     }
// }

// const myCom = Object.create(macBook, {owner: {value: 'Jace'}})
// console.log("myCom :: ", myCom, myCom.__proto__ === macBook)

// const newCom = {...macBook, owner: 'Jace'}
// console.log("newCom :: ", newCom, newCom.__proto__ === macBook)

// macBook.power = 'USB-C'
// console.log(myCom)
// console.log(newCom)


// 4. Singleton / Strict
// - 클래스에 인스턴스가 하나만 있는지 확인하고 이에 대한 전역 액세스 포인트를 제공
// - 다른 인스턴스를 만드려고 시도하면 이미 존재하는 인스턴스 (참조값) 반환
// - 한 개의 인스턴스만 사용하므로 고정 메모리 영역을 할당하여 메모리 낭비 방지와 이미 생성된 인스턴스에 접근하므로 속도 향상 가능
// const DB = (function() {
//     let instance;

//     function createDBInstance() {
//         return new Object('DB Instance')
//     }

//     function getDBInstance() {
//         if (!instance) {
//             instance = createDBInstance()
//         }

//         return instance
//     }

//     return { getDBInstance }
// })()

// const DBInstance1 = DB.getDBInstance()
// const DBInstance2 = DB.getDBInstance()

// console.log(DBInstance1 === DBInstance2)


// [Structural Design Pattern]
// 1. Adapter / Wrapper
// - 호환성이 없는 인터페이스 때문에 동작이 안되는 클래스들을 함께 작동해주도록 변환
// - Ex) 레거시 코드와 새 코드를 연결할 때... or 두 개의 다른 라이브러리를 하나의 유틸리티로 결합할 때...

// old interface
// function Shipping() {
//     this.request = function(zipStart, zipEnd, weight) {

//         return "$100"
//     }
// }

// new interface
// function AdvancedShipping() {
//     this.login = function (credentials) { }
// }

// // adapter
// function ShippingAdapter(credentials) {
//     let legacy = new Shipping()
//     let shipping = new AdvancedShipping()
    
//     shipping.login(credentials)

//     return legacy.request
// }

// function run () {
//     let credentials = { token: '1!Q2@W3#E'}
//     const request = ShippingAdapter(credentials)

//     cost = request('123', '456', '2 lbs')
//     console.log('cost :: ', cost)
// }
// run ()

// 2. Bridge
// - 추상화와 구현을 분리하여 독립적으로 변형 가능한 구조
// - 기능과 구현을 별도로 관리하며 객체 간의 결합도를 낮출 수 있으나 코드 복잡성이 올라감

// Abstraction (추상화)
// class Shape {
//   constructor(color) {
//     this.color = color;
//   }

//   draw() {}
// }

// // 추상화 상속
// class Circle extends Shape {
//   constructor(x, y, radius, color) {
//     super(color);
//     this.x = x;
//     this.y = y;
//     this.radius = radius;
//   }

//   draw() {
//     console.log(`Drawing circle with color ${this.color} at (${this.x},${this.y}) with radius ${this.radius}`);
//   }
// }

// // Implementor (구현)
// class DrawingAPI {
//   drawCircle(x, y, radius) {}
// }

// // Concrete Implementor (구체적인 구현)
// class V2DrawingAPI extends DrawingAPI {
//   drawCircle(x, y, radius) {
//     console.log(`V2DrawingAPI - Drawing circle at (${x},${y}) with radius ${radius}`);
//   }
// }

// // Usage
// class CircleShape {
//   constructor(x, y, radius, color, drawingAPI) {
//     this.shape = new Circle(x, y, radius, color);
//     this.drawingAPI = drawingAPI;
//   }

//   draw() {
//     this.drawingAPI.drawCircle(this.shape.x, this.shape.y, this.shape.radius);
//   }
// }

// 3. Composite
// - 클래스가 구조적인 패턴일 때 단일 객체와 복합 객체를 동일하게 컨트롤 가능하게 함
// - Ex) Directory(파일/폴더) or Node(자기자신/자식) 같은 트리 구조
// function Node(name) {
//     this.children = []
//     this.name = name
// }

// Node.prototype = {
//     add(child) {
//         this.children.push(child)
//     },
//     remove(child) {
//         let length = this.children.length
//         for (let i = 0; i < length; i++) {
//             if (this.children[i] === child) {
//                 this.children.splice(i, 1)
//                 return
//             }
//         }
//     },
//     getChild(i) {
//         return this.children[i]
//     },
//     hasChildren() {
//         return this.children.length > 0
//     }
// }

// function traverse(indent, node) {
//     console.log(node)
//     console.log(Array(++indent).join('--') + node.name)

//     for (let i = 0; i < node.children.length; i++) {
//         traverse(indent, node.getChild(i))
//     }
// }

// function run() {
//     let tree = new Node('root')
//     let left = new Node('left')
//     let right = new Node('right')
//     let rightright = new Node('rightright')

//     tree.add(left)
//     tree.add(right)

//     right.add(rightright)
//     traverse(0, tree)
// }
// run ()


// 4. Decorator
// - 객체의 기능 확장이나 변경이 필요할 때 유연하게 객체의 결합을 하기 위함
// - Ex) 에스프레소에 물, 우유의 조합으로 다양한 커피를 제조할 때

// 클래스 상속
// 클래스와 레시피가 동격...
// function Espresso() {
//     this.cost = 2500
// }
// function Americano() {
//     Espresso.call(this)
//     this.cost = new Espresso().cost + 500
//     this.water = 250
// }
// function CafeLatte() {
//     Americano.call(this)
//     this.cost = new Americano().cost + 500
//     this.milk = 100
// }
// console.log(new Espresso())
// console.log(new Americano())
// console.log(new CafeLatte())

// // 데코레이터 
// // 재료를 생성자 함수로 만들어 원하는 레시피대로 사용...
// function Water(espresso) {
//     espresso.cost = espresso.cost + 500 // won
//     espresso.water = 250 // ml
//     return espresso
// }
// function Milk(espresso) {
//     espresso.cost = espresso.cost + 500
//     espresso.milk = 100
//     return espresso
// }
// const espresso = new Espresso()
// const americano = Water(new Espresso())
// const cafeLatte = Milk(Water(new Espresso()))
// console.log('Espresso :: ', espresso)
// console.log('Americano :: ', americano)
// console.log('CafeLatte :: ', cafeLatte)

// 5. Facade
// - 사용하기 복잡한 클래스에 대해 간편한 인터페이스를 구성하여 사용성을 높임
// - Ex) 일반 유저들은 컴퓨터의 동작 매커니즘을 몰라도 전원 버튼 누르면 자동으로 켜짐
function Init(power) {
    this.power = power
}
Init.prototype = {
    exeCPU() {console.log('exeCPU')},
    readROM() {console.log('readROM')},
    loadBIOS() {console.log('loadBIOS')},
    stopCPU() {console.log('stopCPU')},
    unloadBIOS() {console.log('unloadBIOS')},
}

function turnOn() {
    const init = new Init('on')
    console.log("init :: ", init)
    init.exeCPU()
    init.readROM()
    init.loadBIOS()
}
function turnOff() {
    const init = new Init('off')
    init.unloadBIOS()
    init.stopCPU()
}
turnOn()
turnOff()

// 6. Flyweight
// 7. Proxy

// [Behavioral Design Pattern]
// 1. Chain of Responsibility
// 2. Command
// 3. Iterator
// 4. Mediator
// 5. Memento
// 6. Observer
// 7. State
// 8. Strategy
// 9. Template method
// 10. Visitor

 
 

</script>
</body>
</html>